# Тестовое задание для компании JavaCode на вакансию Junior Golang Developer. Само задание содержится в файле "Тестовое задание golang june+.pdf".

## Как запускать:
1. Клонировать репозиторий.
2. Открыть клонированную папку в консоли.
3. Для первого запуска выполнить команду "docker compose --env-file ./config.env up --build", для всех последующих - "docker compose --env-file ./config.env up".
4. Приложение запустится по адресу "http://localhost:80/api/v1".
5. Документацию Swagger можно будет посмотреть по адресу "http://localhost:8080/api/v1/swagger/".

## Чего не хватает моему решению:
1. Логирование. Желательно в Elasticsearch или типа того.
2. Кэширование. Учитывая то, что над одним и тем же кошельком может осуществляться по тысяче манипуляций в секунду, было бы неплохо хранить кошелек в более быстродоступном хранилищие, чем Postgres (например, Redis) и синхронизировать его с постоянным хранилищем в отдельной асинхронной задаче, не блокирующей основную обработку запроса клиента.
3. Метрики в Prometheus? Данный пункт под вопросом потому, что я сам с метриками не работал, но судя по той инфе, что я нашел по этому вопросу, для реальных сервисов метрики очень полезны и вообще Must Have.

## А что с тестами?
Unit-тестов с помощью пакета testing нет, т. к. я решил обойтись полуавтоматизированными E2E тестами с помощью Postman и JMeter (если надо, я могу показать эти тесты). За все время программирования я пришел к выводу, что повсеместное применение Unit-тестов имеет смысл только тогда, когда они пишутся ДО написания самих тестируемых реализаций (т. е. в методологии TDD). Я же писал сразу реализации и это более чем приемлемый подход, учитывая простоту задания.

## P. S.
Кстати, по поводу JMeter - именно при помощи него я обнаружил баг в своем решении, который нарушает условие задания о работе в конкурентной среде (1000 RPS по
одному кошельку). В чем был баг: за одну секунду 1000 раз прилетел запрос на увеличение баланса изначально пустого кошелька на 1, и в конце всей этой истории на балансе было 762 (хотя, очевидно, должно было быть 1000). Добавление FOR UPDATE к SELECT решило эту проблему.
